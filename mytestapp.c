#include <furi.h>

#include <gui/gui.h>

#include <notification/notification.h>
#include <notification/notification_messages.h>

/* generated by fbt from .png files in images folder */
#include <mytestapp_icons.h>

typedef enum {
    MyEventTypeKey,
    MyEventTypeDone,
} MyEventType;

typedef struct {
    MyEventType type; // The reason for this event.
    InputEvent input; // This data is specific to keypress data.
} MyEvent;

FuriMessageQueue* queue;

int xLimitLow = -2;
int yLimitLow = 8;
int xLimitHigh = 126;
int yLimitHigh = 72;

int x = 2;
int y = 8;

int time = 0;
bool isRunning = false;

static void my_draw_callback(Canvas* canvas, void* context) {
    UNUSED(context);

    char str_time[11];
    itoa(time, str_time, 10);
    char str_x[11];
    itoa(x - xLimitLow, str_x, 10);
    char str_y[11];
    itoa(y - yLimitLow, str_y, 10);

    canvas_set_font(canvas, FontPrimary);
    canvas_draw_str(canvas, 5, 30, "Ahoj!");
    canvas_draw_str(canvas, 5, 40, "T:");
    canvas_draw_str(canvas, 17, 40, str_time);
    canvas_draw_str(canvas, 5, 50, "X:");
    canvas_draw_str(canvas, 17, 50, str_x);
    canvas_draw_str(canvas, 45, 50, "Y:");
    canvas_draw_str(canvas, 57, 50, str_y);
    canvas_draw_str(canvas, x, y, "^");
}

static void my_input_callback(InputEvent* input_event, void* context) {
    UNUSED(context);

    if(input_event->type == InputTypeShort) {
        if(input_event->key == InputKeyLeft) x--;
        if(input_event->key == InputKeyRight) x++;
        if(input_event->key == InputKeyUp) y--;
        if(input_event->key == InputKeyDown) y++;
        if(input_event->key == InputKeyOk) isRunning = !isRunning;
        if(input_event->key == InputKeyBack) {
            MyEvent event;
            event.type = MyEventTypeDone;
            furi_message_queue_put(queue, &event, FuriWaitForever);
        }
    } else if (input_event->type == InputTypeLong) {
        int longDistance = 10;
        if(input_event->key == InputKeyLeft) x = x - longDistance;
        if(input_event->key == InputKeyRight) x = x + longDistance;
        if(input_event->key == InputKeyUp) y = y - longDistance;
        if(input_event->key == InputKeyDown) y = y + longDistance;
        if(input_event->key == InputKeyOk && !isRunning) time = 0;
    }

    if (x > xLimitHigh) x = xLimitHigh;
    if (x < xLimitLow) x = xLimitLow;
    if (y > yLimitHigh) y = yLimitHigh;
    if (y < yLimitLow) y = yLimitLow;
}

static void timer_callback(FuriMessageQueue* event_queue) {
    furi_assert(event_queue);

    if (isRunning) {
        time++;
    }
}

int32_t mytestapp_app(void* p) {
    UNUSED(p);

    void* my_context = NULL;
    queue = furi_message_queue_alloc(8, sizeof(MyEvent));

    ViewPort* view_port = view_port_alloc();
    view_port_draw_callback_set(view_port, my_draw_callback, my_context);
    view_port_input_callback_set(view_port, my_input_callback, my_context);
    view_port_set_orientation(view_port, ViewPortOrientationHorizontal);

    Gui* gui = furi_record_open(RECORD_GUI);
    gui_add_view_port(gui, view_port, GuiLayerFullscreen);

    NotificationApp* notifications = furi_record_open(RECORD_NOTIFICATION);
    notification_message(notifications, &sequence_display_backlight_enforce_on);

    FuriTimer* timer = furi_timer_alloc(timer_callback, FuriTimerTypePeriodic, queue);
    furi_timer_start(timer, 1);

    MyEvent event;

    while(true) {
        if(furi_message_queue_get(queue, &event, FuriWaitForever) == FuriStatusOk) {
            if(event.type == MyEventTypeDone) {
                break;
            }
        } else {
            break;
        }
    }

    notification_message(notifications, &sequence_display_backlight_enforce_auto);

    furi_record_close(RECORD_NOTIFICATION);
    furi_timer_free(timer);
    furi_message_queue_free(queue);
    view_port_enabled_set(view_port, false);
    gui_remove_view_port(gui, view_port);
    furi_record_close(RECORD_GUI);
    view_port_free(view_port);

    return 0;
}
